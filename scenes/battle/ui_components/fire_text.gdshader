shader_type canvas_item;

// ================= ç«ç„°å¤–è§€åƒæ•¸ =================
uniform float fire_speed     = 3.8;  // ç«ç„°å¾€ä¸Šæµå‹•é€Ÿåº¦
uniform float distortion_amp = 1.5;  // ğŸ”¥ å¢åŠ æ‰­æ›²å¹…åº¦(åŸ1.07)
uniform float flame_height   = 3.4;  // ç«ç„°é«˜åº¦
uniform float glow_intensity = 1.2;  // ğŸ”¥ æé«˜æ•´é«”äº®åº¦

// é¡è‰²æ¼¸å±¤ï¼šåº•éƒ¨ â†’ ä¸­æ®µ â†’ é ‚ç«¯
uniform vec3 base_color = vec3(0.85, 0.30, 0.05); // æ·±ç´…æ©˜
uniform vec3 mid_color  = vec3(1.00, 0.60, 0.10); // æ©˜è‰²
uniform vec3 tip_color  = vec3(1.00, 0.95, 0.60); // ç«èˆŒåç™½

// ================= é‚Šç·£ç‡ƒç‡’è¨­å®š =================
uniform float outline_size        = 3.0;  // ğŸ”¥ å¢åŠ å¤–åœˆåšåº¦(åŸ2.0)
uniform float edge_burn_intensity = 2.5;  // ğŸ”¥ å¢å¼·é‚Šç·£ç‡ƒç‡’(åŸ1.8)

// ================= ğŸ”¥ æ–°å¢ï¼šçºç¹æ§åˆ¶ =================
uniform float wrap_frequency = 3.0;  // çºç¹é »ç‡(èºæ—‹åœˆæ•¸)
uniform float wrap_amplitude = 0.15; // çºç¹å¹…åº¦(å·¦å³æ“ºå‹•è·é›¢)
uniform float turbulence     = 1.5;  // äº‚æµå¼·åº¦

// ================= ç°¡æ˜“ 2D å™ªè² / fBm =================
float hash(vec2 p) {
	p = vec2(
		dot(p, vec2(127.1, 311.7)),
		dot(p, vec2(269.5, 183.3))
	);
	return fract(sin(p.x + p.y) * 43758.5453123);
}

float noise(vec2 p) {
	vec2 i = floor(p);
	vec2 f = fract(p);
	float a = hash(i);
	float b = hash(i + vec2(1.0, 0.0));
	float c = hash(i + vec2(0.0, 1.0));
	float d = hash(i + vec2(1.0, 1.0));
	vec2 u = f * f * (3.0 - 2.0 * f);
	return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

float fbm(vec2 p) {
	float v = 0.0;
	float a = 0.5;
	for (int i = 0; i < 5; i++) {  // ğŸ”¥ å¢åŠ è¿­ä»£æ¬¡æ•¸(åŸ4)
		v += a * noise(p);
		p *= 2.0;
		a *= 0.5;
	}
	return v;
}

// ================= Fragment =================
void fragment() {
	// åŸå§‹æ–‡å­— alpha
	vec4 tex = texture(TEXTURE, UV);
	float base_alpha = tex.a;
	
	// ------------ (1) æ“´å¼µ alpha ------------
	vec2 px = TEXTURE_PIXEL_SIZE * outline_size;
	float max_a = 0.0;
	for (int x = -1; x <= 1; x++) {
		for (int y = -1; y <= 1; y++) {
			vec2 offset = vec2(float(x), float(y)) * px;
			max_a = max(max_a, texture(TEXTURE, UV + offset).a);
		}
	}
	float expanded_alpha = max_a;
	
	if (expanded_alpha < 0.01) {
		discard;
	}
	
	float edge = clamp(expanded_alpha - base_alpha, 0.0, 1.0);
	
	// ------------ (2) ğŸ”¥ åŠ å¼·ç«ç„°çºç¹æ•ˆæœ ------------
	float v = 1.0 - UV.y;
	float t = TIME * fire_speed;
	
	// èºæ—‹çºç¹ï¼šéš¨è‘—é«˜åº¦æ—‹è½‰
	float wrap_angle = v * wrap_frequency * 6.2831 + t;
	float wrap_offset = sin(wrap_angle) * wrap_amplitude;
	
	// å¤šå±¤å™ªè²ç–ŠåŠ ï¼Œè£½é€ è¤‡é›œäº‚æµ
	vec2 p1 = vec2(UV.x * 4.0 + wrap_offset, v * 6.0 + t);
	vec2 p2 = vec2(UV.x * 6.0 - wrap_offset * 0.5, v * 8.0 + t * 1.3);
	vec2 p3 = vec2(UV.x * 3.0 + wrap_offset * 1.5, v * 5.0 + t * 0.7);
	
	float n1 = fbm(p1);
	float n2 = fbm(p2) * 0.5;
	float n3 = fbm(p3) * 0.3;
	float n = (n1 + n2 + n3) / 1.8;
	
	// å¢å¼·æ‰­æ›²æ•ˆæœ
	float distort = (n - 0.5) * 2.0 * distortion_amp * (1.0 + v * turbulence);
	
	// ç«ç„°é«˜åº¦é®ç½©
	float flame_mask = smoothstep(0.0, 1.0, v * flame_height + distort);
	
	// ğŸ”¥ æ–°å¢ï¼šå‹•æ…‹è„ˆå‹•æ•ˆæœ
	float pulse = 0.9 + 0.1 * sin(TIME * 4.0 + UV.x * 10.0);
	flame_mask *= pulse;
	
	// ------------ (3) é¡è‰²æ¼¸å±¤ ------------
	vec3 col = base_color;
	col = mix(col, mid_color, clamp(v * 1.3, 0.0, 1.0));
	col = mix(col, tip_color, clamp(v * 1.8, 0.0, 1.0)); // ğŸ”¥ æ›´å¿«è®Šç™½(åŸ1.6)
	
	// å™ªè²æ§åˆ¶äº®åº¦
	float brightness = 0.5 + 0.5 * n;  // ğŸ”¥ æ›´å¼·å°æ¯”(åŸ0.6+0.4)
	col *= brightness;
	
	// ğŸ”¥ å¢å¼·é–ƒçˆæ•ˆæœ
	float flicker = 0.8 + 0.2 * sin(TIME * 8.0 + n * 15.0);
	col *= flicker;
	
	// ------------ (4) é‚Šç·£ç‡ƒç‡’åŠ å¼· ------------
	vec3 edge_color = vec3(1.0, 0.97, 0.85);
	float edge_factor = clamp(edge * edge_burn_intensity, 0.0, 1.0);
	
	// ğŸ”¥ é‚Šç·£åŠ å…¥å™ªè²ï¼Œè®“ç‡ƒç‡’æ›´ä¸è¦å‰‡
	edge_factor *= (0.8 + 0.4 * n);
	col = mix(col, edge_color, edge_factor);
	
	// ------------ (5) æœ€çµ‚è¼¸å‡º ------------
	float final_alpha = expanded_alpha * flame_mask;
	col *= glow_intensity;
	
	// ğŸ”¥ æ–°å¢ï¼šå¤–åœˆåŠé€æ˜ç«ç„°å±¤
	float outer_glow = edge * 0.3 * (1.0 - v);
	final_alpha = clamp(final_alpha + outer_glow, 0.0, 1.0);
	
	COLOR = vec4(col, final_alpha);
}